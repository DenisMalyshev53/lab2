# Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнил: `Малышев Денис Валерьевич`

#### Вариант: `16`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

> Напишите программу на Java, которая выполняет следующие действия с
двумерным массивом вещественных чисел (каждая строка может иметь
разную длину):
1. Считывает с консоли число строк N. Затем для каждой строки вводит количество элементов Mi, после чего вводит элементы строки, формируя массив размером N строк разной длины.
2. Сортирует строки массива по возрастанию количества отрицательных чисел в строке. Если количества равны, сортирует строки по возрастанию суммы положительных чисел.
3. Находит и выводит максимальное число в массиве и его индексы (номер строки и позиция в строке).
4. Выводит элементы массива в виде матрицы, заполняя недостающие элементы в строках символом ‘*’.
5. Заменяет все числа в массиве на их обратные значения (1/число) и выводит полученный массив.

- Для первой задачи зададим двумерный массив на N строк, а Mi уже будем указывать для каждой строки отдельно.
- Для второй задачи будем проходиться поочерёдно по каждой строке и сравнивать её с последующими, при этом считая количество отрицательных и положительных элементов в них. Далее
будем сравнивать эти значения и исходя из сравнения решать менять или не менять строки местами.
- Для третьей задачи будем поочерёдно проходиться по всем элементам массива и находить из них максимальный.
- Для четвёртой задачи будем искать строку с максимальной длиной и дополнять остальные строки символами "*" до этой длины.
- Для пятой задачи будем поочерёдно проходиться по элементам массива и заменять их на обратные им значения.

### 2. Входные и выходные данные

#### Данные на вход

На вход программа должна получать количество строк, длину каждой строки и элементы каждой строки. Количество строк и их длина, очевидно, целые числа. Элементы массива по условию являются
вещественными числами.

|             | Тип               | min значение    | max значение   |
|-------------|-------------------|-----------------|----------------|
| N (количество строк массива) | Целое число |        -2147483648        |      2147483647      |
| Mi (длина каждой строки) | Целое число |        -2147483648        |      2147483647      |
| a[i][j] (элемент строки) | Вещественное число |        1,7e-308        |      1,7e+308      |

#### Данные на выход

На выходе получаем начальный массив, а потом изменения этого массива по ходу моей задачи.

|         | Тип                                |
|---------|------------------------------------|
| Начальный массив | Вещественные числа |
| Отсортированный по возрастанию количества отрицательных чисел или по сумме положительных чисел массив| Вещественные числа |
| Максимальный элемент | Вещественные числа |
| Индекс максимального элемента | Целые числа |
| Массива в виде матрицы, заполненный символом ‘*’ вместо недостающих элементов| Вещественные числа и символы |
| Массив после замены всех чисел на обратные значения | Вещественные числа |
### 3. Выбор структуры данных
На входе программа получает колчество строк массива N, длину каждой отдельной строки Mi и каждый элемент для этой строки. Для N и Mi будем использовать, очевидно,
целочисленный тип данных. Для хранения элементов в массиве будем использовать вещественный тип данных, тк элементы массива- вещественные числа по условию. Для
некоторых дальнейших вычислений в программе для хранения переменных используются те же целочисленный и вещественный типы данных.

| Название переменной | Тип (в Java) | 
|---------------------|--------------|
| N                 | int     |
| Mi                 | int     |
| a                 | double     |
| k1                 | int     |
| k2                 | int     |
| sum1                 | double     |
| sum2                 | double     |
| z                 | double     |
| a                 | double     |
| maxStr                 | int     |
| maxStol                 | int     |
| maxi                 | double     |
| maxL                 | int     |

### 4. Алгоритм

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа получает количество строк массива N, длину каждой отдельной строки Mi и каждый элемент строки массива.

2. **Преобразования массива:**  
- Для второй задачи будем проходиться поочерёдно по каждой строке и сравнивать её с последующими, при этом считая количество отрицательных и положительных элементов в них и в рассматриваемой строке. Далее
будем сравнивать эти значения и ,если количество отрицательных элементов в какой либо последующей после рассмотриваемой строке будет меня чем в рассматриваемой, то производим замену строк.
Если же количества отрицательных чисел равны, то сравниваем сумму положительных и работаем по тому же принципу.
- Для третьей задачи изначально максимальным возьмем элемент массива с индексом [0][0], затем будем поочерёдно проходиться по всем элементам массива и сравнивать их с максимальным. Если 
рассматриваемый элемент окажется больше максимального, запишем его как максимальный и перейдем к следующему элементу. И так пока не пройдемся по всему массиву.
- Для четвёртой задачи будем искать строку с максимальной длиной по такому же алгоритму, что и в задаче 3 искали максимальный элемент. Далее будем рассматривать каждую строку отдельно и поочерёдно выводить её элементы.
Псле того как вывели все элементы сосздадим цикл, начинающийся с длины данной строки. В самом цикле будем выводить символ "*", пока длина строки не станет больше или равна длины максимальной строки.
- Для пятой задачи будем поочерёдно проходиться по элементам массива и заменять их на обратные им значения.

3. **Вывод результата:**  
   Программа выведет сначала начальный массив, а потом изменения этого массива по ходу моей задачи.

### 4. Программа

```java
import java.util.Scanner;
public class Main{
    public static Scanner in=new Scanner(System.in);
    public static void main(String[] args){
        int N=in.nextInt(); //вводим количество строк массива
        double [][]a=new double[N][]; //задаем двумерный массив N строк
        for(int i=0;i<a.length;i++){ //проходимся по строкам массива
            int Mi=in.nextInt(); //задаем количество элементов в строке
            a[i]=new double[Mi]; //задаем строку массива длиной M
            for(int j=0;j<a[i].length;j++){ //проходимя по каждому элементу строки
                a[i][j]=in.nextDouble(); //задаем каждый элемент строки
            }
        }
        System.out.println("Начальный массив");
        for(int i=0;i<a.length;i++){ //проходимся по строкам массива
            for(int j=0;j<a[i].length;j++){ //проходимя по каждому элементу строки
                System.out.print(a[i][j]+ " "); //выводим каждый элемент строки
            }
            System.out.println();
        }


        for(int i=0;i<a.length-1;i++){ //берем строку массива, единицу вычитаем тк j=i+1
            for(int j=i+1;j<a.length;j++){ //берем другую строку массива
                int k1=0; //инициализируем k1 для подсчета отрицательных элементов взятой строки
                int k2=0; //инициализируем k2 для подсчета отрицательных элементов другой строки
                double sum1=0; //инициализируем sum1 для подсчета суммы неотрицательных элементов взятой строки
                double sum2=0; //инициализируем sum2 для подсчета суммы неотрицательных элементов другой строки
                //подсчет отрицательных и положительных чисел в строках
                for (int k=0;k<a[i].length;k++){ //берем элемент строки i с индексом к
                    if (a[i][k]<0){ // проверяем, отрицательный ли элемент
                        k1+=1; // если отрицательный, то прибавляем 1 к к1
                    }
                    else {
                        sum1+=a[i][k]; //если неотрицательный, то прибавляем элемент к общей сумме неотрицательных в строке
                    }
                }
                for (int k=0;k<a[j].length;k++){ //берем элемент строки j с индексом к
                    if (a[j][k]<0){ // проверяем, отрицательный ли элемент
                        k2+=1; // если отрицательный, то прибавляем 1 к к2
                    }
                    else{
                        sum2+=a[j][k]; //если неотрицательный, то прибавляем элемент к общей сумме неотрицательных в строке
                    }
                }
                //сравнение количества отрицательных чисел
                if (k1>k2){ //проверяем условие что k1 больше k2
                    //обмен строк
                    double[] z=a[i];
                    a[i]=a[j];
                    a[j]=z;
                } else if(k1==k2){
                    //сравнение суммы положительных чисел
                    if(sum1>sum2){ //проверяем условие что sum1 больше sum2
                        //обмен строк
                        double[] z=a[i];
                        a[i]=a[j];
                        a[j]=z;
                    }
                }
            }
        }


        System.out.println("Сортировка массива по возрастанию количества отрицательных чисел в строке \n" +
                "или по возрастанию суммы положительных");
        //выводим получивщийся массив по обычному алгоритму
        for(int i=0;i<a.length;i++){
            for(int j=0;j<a[i].length;j++){
                System.out.print(a[i][j]+ " ");
            }
            System.out.println();
        }

        int maxStr=0; //инициализируем maxStr для обозначения индекса строки максимального элемента массива
        int maxStol=0; //инициализируем maxStol для обозначения индекса максимального элемента массива в строке
        double maxi=a[0][0]; //возьмем первый элемент массива как максимальный
        for (int i=0;i<a.length;i++){ //проходимся по строкам массива
            for (int j=0;j<a[i].length;j++){ //проходимся по элементам строки
                if (a[i][j]>maxi){ //проверяем больше ли взятый элемени максимального элемента
                    //если условие выполняется, то:
                    maxi=a[i][j]; //взятый элемент становится максимальным
                    maxStr=i; //записываем строку максимального элемента
                    maxStol=j; //записываем индекс максимального элемента в строке
                }
            }
        }
        System.out.println("Максимальный элемент: " + maxi);
        System.out.println("Индексы максимального элемента: [" + maxStr + ", " + maxStol + "]");

        //найдем максимальную длину строки
        int maxL=0; //инициализируем maxL для обозначения максимальной длины
        for (int i=0;i<a.length;i++){ //проходимся по строкам массива
            if (a[i].length>maxL){ //проверяем что длина взятой строки больше максимальной длины строки
                // если да, то:
                maxL=a[i].length; //записываем длину взятой строки как максимальную
            }
        }

        System.out.println("Вывод массива в виде матрицы");
        for (int i=0; i<a.length;i++){ //проходимся по строкам массива
            for (int j=0; j<a[i].length;j++){ //проходимся по элементам строк
                System.out.print(a[i][j] + " "); //выводим элементы строки
            }
            for (int j=a[i].length; j<maxL;j++){ /* заполняем оставшуюся строку символами "*" до тех пор,
             пока не дойдем до длины максимальной строки*/
                System.out.print("* ");
            }
            System.out.println();
        }
         //заменяем числа массива на обратные
        for (int i=0;i<a.length;i++){ //проходимся по каждой строке массива
            for (int j=0;j<a[i].length;j++){ //проходимся по каждому элементу в строке
                if (a[i][j]!=0) {//проверяем что элемент не равен 0, чтобы не было деления на 0
                    a[i][j]=1/a[i][j]; //заменяем элемент на обратный ему
                }
            }
        }
        System.out.println("Массив после замены всех чисел на обратные значения");
        //выводим получивщийся массив по обычному алгоритму
        for (int i=0;i<a.length;i++){
            for (int j=0;j<a[i].length;j++){
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

### 6. Анализ правильности решения

Рассмотрим различные случаи для каждой задачи.

1. Тест для задачи 1:

    - **Input**:
        ```
        3
        3 1 2 3
        3 1 2 3
        3 1 2 3
        ```

    - **Output**:
        ```
        Начальный массив
        1.0 2.0 3.0 
        1.0 2.0 3.0 
        1.0 2.0 3.0 
        Сортировка массива по возрастанию количества отрицательных чисел в строке
        1.0 2.0 3.0 
        1.0 2.0 3.0 
        1.0 2.0 3.0 
        Максимальный элемент: 3.0
        Индексы максимального элемента: [0, 2]
        Вывод массива в виде марицы
        1.0 2.0 3.0 
        1.0 2.0 3.0 
        1.0 2.0 3.0 
        Массив после замены всех чисел на обратные значения
        1.0 0.5 0.3333333333333333 
        1.0 0.5 0.3333333333333333 
        1.0 0.5 0.3333333333333333
        ```

2. Тесты если максимальное количество отрицательных элементов в 1 строке, в 3 и 4 строке их количество одинаково, в массиве присутсвует 0, в массиве присутвует строка с наибольшей длиной,
   в массиве 2 максимальных числа:

    - **Input**:
        ```
        5
        5 -1,2 -4 -3,7 -6 7
        3 0 7 1
        4 -5 -6,7 5,8 9
        3 -1,4 -8 45 
        2 45 7
        ```

    - **Output**:
        ```
        Начальный массив
        -1.2 -4.0 -3.7 -6.0 7.0 
        0.0 7.0 1.0 
        -5.0 -6.7 5.8 9.0 
        -1.4 -8.0 45.0 
        45.0 7.0 
        Сортировка массива по возрастанию количества отрицательных чисел в строке 
        или по возрастанию суммы положительных
        0.0 7.0 1.0 
        45.0 7.0 
        -5.0 -6.7 5.8 9.0 
        -1.4 -8.0 45.0 
        -1.2 -4.0 -3.7 -6.0 7.0 
        Максимальный элемент: 45.0
        Индексы максимального элемента: [1, 0]
        Вывод массива в виде марицы
        0.0 7.0 1.0 * * 
        45.0 7.0 * * * 
        -5.0 -6.7 5.8 9.0 * 
        -1.4 -8.0 45.0 * * 
        -1.2 -4.0 -3.7 -6.0 7.0 
        Массив после замены всех чисел на обратные значения
        0.0 0.14285714285714285 1.0 
        0.022222222222222223 0.14285714285714285 
        -0.2 -0.14925373134328357 0.1724137931034483 0.1111111111111111 
        -0.7142857142857143 -0.125 0.022222222222222223 
        -0.8333333333333334 -0.25 -0.27027027027027023 -0.16666666666666666 0.14285714285714285
        ```

3. Тест если максимальное количество элементов в последней строке, а в 1 и 2 их количество одинаково:

    - **Input**:
        ```
        4
        5 -2,8 9 -7,8 3 5
        3 -1,2 -4 1
        4 1 2 3 4
        3 -1,4 -8 -6,9
        ```

    - **Output**:
        ```
      Начальный массив
      -2.8 9.0 -7.8 3.0 5.0 
      -1.2 -4.0 1.0 
      1.0 2.0 3.0 4.0 
      -1.4 -8.0 -6.9 
      Сортировка массива по возрастанию количества отрицательных чисел в строке 
      или по возрастанию суммы положительных
      1.0 2.0 3.0 4.0 
      -1.2 -4.0 1.0 
      -2.8 9.0 -7.8 3.0 5.0 
      -1.4 -8.0 -6.9 
      Максимальный элемент: 9.0
      Индексы максимального элемента: [2, 1]
      Вывод массива в виде матрицы
      1.0 2.0 3.0 4.0 * 
      -1.2 -4.0 1.0 * * 
      -2.8 9.0 -7.8 3.0 5.0 
      -1.4 -8.0 -6.9 * * 
      Массив после замены всех чисел на обратные значения
      1.0 0.5 0.3333333333333333 0.25 
      -0.8333333333333334 -0.25 1.0 
      -0.35714285714285715 0.1111111111111111 -0.12820512820512822 0.3333333333333333 0.2 
      -0.7142857142857143 -0.125 -0.14492753623188406
        ```

4. Тест если максимальное количество отрицательных элементов не в 1 и не в последней строке,
а в первой и последней их одинаковое количество.

    - **Input**:
        ```
        5
        4 -1 -2 4,7 9
        3 0,8 0,2 0,1
        4 -1 -1 -2 -3
        2 0,3 0,9
        3 -3 -4 3 3,6
        ```

    - **Output**:
        ```
        Начальный массив
        -1.0 -2.0 4.7 9.0 
        0.8 0.2 0.1 
        -1.0 -1.0 -2.0 -3.0 
        0.3 0.9 
        -3.0 -4.0 3.0 
        Сортировка массива по возрастанию количества отрицательных чисел в строке 
        или по возрастанию суммы положительных
        0.8 0.2 0.1 
        0.3 0.9 
        -3.0 -4.0 3.0 
        -1.0 -2.0 4.7 9.0 
        -1.0 -1.0 -2.0 -3.0 
        Максимальный элемент: 9.0
        Индексы максимального элемента: [3, 3]
        Вывод массива в виде матрицы
        0.8 0.2 0.1 * 
        0.3 0.9 * * 
        -3.0 -4.0 3.0 * 
        -1.0 -2.0 4.7 9.0 
        -1.0 -1.0 -2.0 -3.0 
        Массив после замены всех чисел на обратные значения
        1.25 5.0 10.0 
        3.3333333333333335 1.1111111111111112 
        -0.3333333333333333 -0.25 0.3333333333333333 
        -1.0 -0.5 0.2127659574468085 0.1111111111111111 
        -1.0 -1.0 -0.5 -0.3333333333333333
        
        ```

5. Тест если все числа неотрицательные и длины строк одинаковые:

    - **Input**:
        ```
        3
        3 5 6 7
        3 4 5 6
        3 1 2 3
        ```

    - **Output**:
        ```
        Начальный массив
        5.0 6.0 7.0 
        4.0 5.0 6.0 
        1.0 2.0 3.0 
        Сортировка массива по возрастанию количества отрицательных чисел в строке 
        или по возрастанию суммы положительных
        1.0 2.0 3.0 
        4.0 5.0 6.0 
        5.0 6.0 7.0 
        Максимальный элемент: 7.0
        Индексы максимального элемента: [2, 2]
        Вывод массива в виде матрицы
        1.0 2.0 3.0 
        4.0 5.0 6.0 
        5.0 6.0 7.0 
        Массив после замены всех чисел на обратные значения
        1.0 0.5 0.3333333333333333 
        0.25 0.2 0.16666666666666666 
        0.2 0.16666666666666666 0.14285714285714285
        ```
6. Тест если все числа отрицательные:

    - **Input**:
        ```
        3
        3 -1 -2 -3
        3 -1 -2 -4
        3 -6 -7,8 -1,3
        ```

    - **Output**:
        ```
        Начальный массив
        -1.0 -2.0 -3.0 
        -1.0 -2.0 -4.0 
        -6.0 -7.8 -1.3 
        Сортировка массива по возрастанию количества отрицательных чисел в строке 
        или по возрастанию суммы положительных
        -1.0 -2.0 -3.0 
        -1.0 -2.0 -4.0 
        -6.0 -7.8 -1.3 
        Максимальный элемент: -1.0
        Индексы максимального элемента: [0, 0]
        Вывод массива в виде матрицы
        -1.0 -2.0 -3.0 
        -1.0 -2.0 -4.0 
        -6.0 -7.8 -1.3 
        Массив после замены всех чисел на обратные значения
        -1.0 -0.5 -0.3333333333333333 
        -1.0 -0.5 -0.25 
        -0.16666666666666666 -0.12820512820512822 -0.7692307692307692
        ```
